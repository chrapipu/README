# **Программное средство реализации аналитического решения в сфере розничных продаж в food-ритейле**

Программное средство реализации аналитического решения в сфере розничных продаж в food-ритейле предназначено для комплексного анализа данных о продажах в розничной торговле продуктами питания. Оно позволяет загружать файлы в формате Excel/CSV и автоматически обрабатывать их, рассчитывая ключевые бизнес‑, маркетинговые и операционные метрики. Результаты анализа визуализируются в виде дашбордов, что позволяет владельцам и менеджерам по продажам быстро выявлять тренды, проблемные зоны и точки роста, принимать обоснованные управленческие решения и повышать эффективность бизнеса.

Сервер: https://github.com/chrapipu/FoodRetail_back
Клиент: https://github.com/chrapipu/FoodRetail_front

---

## **Содержание**

1. [Архитектура](#Архитектура)
	1. [C4-модель](#C4-модель)
	2. [Схема данных](#Схема_данных)
2. [Функциональные возможности](#Функциональные_возможности)
	1. [Диаграмма вариантов использования(#Диаграмма_вариантов_использования)]
	2. [User-flow диаграммы](#User-flow_диаграммы)
3. [Детали реализации](#Детали_реализации)
	1. [UML-диаграммы](#UML-диаграммы)
	2. [Спецификация API](#Спецификация_API)
	3. [Безопасность](#Безопасность)
	4. [Оценка качества кода](#Оценка_качества_кода)
4. [Тестирование](#Тестирование)
	1. [Unit-тесты](#Unit-тесты)
	2. [Интеграционные тесты](#Интеграционные_тесты)
5. [Установка и  запуск](#installation)
	1. [Манифесты для сборки docker образов](#Манифесты_для_сборки_docker_образов)
	2. [Манифесты для развертывания k8s кластера](#Манифесты_для_развертывания_k8s_кластера)
6. [Лицензия](#Лицензия)
7. [Контакты](#Контакты)

---
## **Архитектура**

### C4-модель

Для описания архитектурных решений программного продукта используется нотация C4 model, которая представляет архитектуру на четырех уровнях декомпозиции. Каждый последующий уровень детализирует предыдущий, включая четыре уровня абстракции: контекст, контейнеры, компоненты и классы. На уровне контекста показывается обзор системы и ее взаимодействие с окружением. 
Для разрабатываемого программного средства он представлен на рисунке 1.

<img width="651" height="478" alt="image" src="https://github.com/user-attachments/assets/444f95a1-5349-43ae-93f0-d5217c2c0819" />
 
Рисунок 1 – Контекстная диаграмма

Следующим уровнем представления архитектуры является контейнерный. В нем составные части архитектуры, определенные на контекстном уровне, декомпозируются для предоставления информации о технических блоках высокого уровня. Данный уровень представления архитектуры представлен на рисунке 2.

<img width="608" height="559" alt="image" src="https://github.com/user-attachments/assets/6c23a5a3-c8ef-4a43-aa43-b16625db46ec" />


Рисунок 2 – Контейнерный уровень представления архитектуры

Следующим уровнем представления архитектуры является компонентный. В нем представляются внутренние блоки контейнеров, определенные на контейнерном уровне. Компонентный уровень представления архитектуры представлен на рисунке 3.

<img width="1045" height="599" alt="image" src="https://github.com/user-attachments/assets/e6b35441-485a-40be-9253-942cb9d142fd" />


 
Рисунок 3 – Компонентный уровень представления архитектуры

Самым нижним уровнем представления архитектуры является кодовый. В нем представляется внутренняя организация компонентов, определенных на компонентном уровне. Кодовый уровень представления архитектуры представлен ниже на рисунке 4.

<img width="801" height="446" alt="image" src="https://github.com/user-attachments/assets/03e1b08b-8f65-440d-9e6b-d21d15cd9cb0" />
 

Рисунок 4 – Кодовый уровень представления архитектуры

Таким образом была разработана архитектура программного приложения, в соответствии с которой оно было разработано. 
Чистая архитектура аналитического решения в food-ритейле строится на принципе разделения ответственности между слоями, где каждый слой решает строго определённую задачу и не зависит от технических деталей других. Это позволяет системе быть гибкой, масштабируемой и легко объяснимой – как для команды разработки, так и при защите архитектурных решений.
В центре находится слой бизнес-логики, который включает в себя основные сущности: продажа, товар, категория, акция, а также метрики – выручка, средний чек, процент брака, эффективность акций. Эти сущности описывают, как работает розничный бизнес, и используются в сценариях анализа, фильтрации и отчётности. Например, сущность Sale содержит дату, товар, сумму и привязку к акции, а KPI агрегирует расчётные показатели.
Слой сценариев реализует прикладную логику: фильтрация продаж по параметрам, расчёт KPI, экспорт отчётов, валидация загружаемых данных. Каждый сценарий оформлен как отдельный use case, который принимает входные параметры, обрабатывает их с помощью бизнес-сущностей и возвращает результат. Например, FilterSalesUseCase получает объект FilterCriteria, извлекает данные через репозиторий, применяет фильтры и возвращает отфильтрованный список. CalculateKPIUseCase получает продажи и рассчитывает ключевые показатели. ExportReportUseCase формирует PDF на основе текущих данных и визуализаций.
Слой адаптеров связывает бизнес-логику с внешним миром. Контроллеры принимают HTTP-запросы, преобразуют их в команды или запросы и передают в соответствующие обработчики. Например, SalesController обрабатывает POST-запрос на загрузку файла, вызывает UploadSalesHandler, а KPIController обрабатывает GET-запрос и вызывает GetKPIHandler. DTO и мапперы преобразуют данные между слоями, репозитории реализуют доступ к базе, презентеры формируют ответ для UI.
Слой инфраструктуры реализует технические детали: Spring Boot – для запуска и конфигурации, Spring Data JPA – для доступа к данным, PostgreSQL – для хранения фактов продаж, React SPA – для визуализации и взаимодействия с пользователем, JWT – для авторизации. 


### Схема данных

Пользователи и роли. Таблица users – зарегистрированные пользователи системы. Хранит базовую информацию о менеджерах и директорах. Атрибуты:

– id (PK) – уникальный идентификатор пользователя

– username – имя или логин;

– email –  электронная почта (уникальная);

– password_hash –  хэш пароля.

Таблица user_roles – модель ролевого доступа.

Позволяет управлять правами пользователей.

Атрибуты:

– user_id (PK, FK → users.id) –  идентификатор пользователя;

– role – роль в системе (ROLE_MANAGER, ROLE_DIRECTOR).

Продажи и товары. Таблица categories хранит справочник товарных категорий. Атрибуты: 

– id (PK) – уникальный идентификатор категории; 

– name – наименование категории.

Таблица products содержит информацию о товарах. Атрибуты: 

– id (PK) – уникальный идентификатор товара;

– name – наименование товара; 

– category_id (FK → categories.id) – категория товара;

– supplier_name – поставщик;

– price – цена;

– promo_flag – участвует ли товар в акции (true, false); 

– unit – единица измерения (шт, кг, л).

Таблица sales фиксирует факты продаж. Атрибуты: 

– id (PK) – уникальный идентификатор продажи; 

– product_id (FK → products.id) – проданный товар;

– quantity – количество; 

 – total_amount – сумма;
–
sale_date – дата продажи.

Аналитика. Таблица product_metrics – показатели по товарам. Фиксирует ключевые метрики по каждому товару за период. Атрибуты:

– product_id (FK → products.id) – товар;

– period – период агрегации (2025‑10, 2025‑Q3, 2025‑W40);

– total_sales (FK → sales. total_amount) – сумма продаж;

– units_sold (FK → sales. quantity) – количество проданных единиц;

– avg_unit_price (FK → sales.AVG(total_amount / quantity))  – средняя цена за единицу;

– promo_share (FK → products.promo_flag)  – доля продаж по акции (в процентах).

Таблица sales_summary – сводные показатели по продажам. Фиксирует ключевые метрики по всем продажам за период, независимо от конкретного товара. Атрибуты: 

– period – период агрегации (например, 2025 10, 2025 Q3, 2025 W40); 

– total_revenue (FK → sales.total_amount) – общая сумма продаж за период;

 – total_units_sold (FK → sales.quantity) – общее количество проданных единиц; 
–
average_check (FK → sales.AVG(total_amount)) – средний чек; 

– top_category (FK → products.category) – категория с наибольшей выручкой; 

Таблица category_metrics – показатели по товарным категориям. Агрегирует ключевые метрики по каждой категории товаров за период. Атрибуты: 

– category (FK → category.id) – наименование категории; 

– period – период агрегации (например, 2025 10, 2025 Q3, 2025 W40); 

– units_sold (FK → sales.quantity) – общее количество проданных единиц в категории; 

– total_sales (FK → sales.total_amount) – суммарная выручка по категории; 

– avg_unit_price (FK → sales.AVG(total_amount / quantity)) – средняя цена за единицу;

– promo_share (FK → products.promo_flag) – доля акционных продаж в категории (в процентах); 

– top_product (FK → products.id) – самый продаваемый товар в категории (по выручке);

Таблица check_dynamics – динамика среднего чека. Позволяет отслеживать, как меняется средний чек по дням, неделям или месяцам. Атрибуты: 

– period – период агрегации (2025 10 08, 2025 W40, 2025 10);

– average_check (FK → sales.AVG(total_amount)) – средний чек за период;

– min_check (FK → sales.MIN(total_amount)) – минимальный чек;

– max_check (FK → sales.MAX(total_amount)) – максимальный чек;

– promo_check – средний чек по акционным товарам (WHERE pro-mo_flag = true); 

– non_promo_check – средний чек по обычным товарам (WHERE pro-mo_flag = false).

Таблица revenue_metrics – детализация выручки. Фиксирует структуру выручки по товарам и категориям за период, с возможностью анализа акций. Атрибуты: 

– period – период агрегации (2025 10, 2025 Q3, 2025 W40);

– product_id (FK → products.id) – товар;

– category (FK → category.id) – категория товара;

– total_revenue (FK → sales.total_amount) – суммарная выручка по товару;

– promo_revenue – выручка от акционных продаж (WHERE promo_flag = true);

– non_promo_revenue – выручка от обычных продаж (WHERE pro-mo_flag = false); 

– revenue_share – доля товара в общей выручке за период (в процентах).

<img width="926" height="572" alt="image" src="https://github.com/user-attachments/assets/d5628c3a-51b7-440d-8180-c9fb4ab93340" />

Рисунок 1 – Схема базы данных

Обоснование приведения к 3НФ. 
Первая нормальная форма (1НФ):
Все атрибуты атомарные (например, username, email, price, sale_date не содержат составных или повторяющихся значений).
Нет повторяющихся групп – каждая таблица фиксирует только один тип сущности: пользователи, роли, категории, товары, продажи.
Вторая нормальная форма (2НФ):
Все неключевые атрибуты зависят от полного первичного ключа. 
– В users атрибуты username, email, password_hash зависят только от id. 
– В products атрибуты name, category_id, supplier_name, price, pro-mo_flag, unit зависят только от id. 
– В sales атрибуты product_id, quantity, total_amount, sale_date зависят только от id.
В аналитических таблицах (product_metrics, sales_summary, catego-ry_metrics, check_dynamics, revenue_metrics) все показатели зависят от составного ключа (period + ссылка на товар/категорию).
Третья нормальная форма (3НФ):
Нет транзитивных зависимостей: 
– Данные о пользователях хранятся только в users, а не дублируются в user_roles или аналитике. 
– Данные о категориях хранятся только в categories, а не дублируются в products. 
– Данные о товарах хранятся только в products, а не дублируются в sales или аналитике. 
– В аналитических таблицах (*_metrics, sales_summary, check_dynamics) хранятся только агрегированные показатели, а не справочные данные о товарах или пользователях.
Таким образом, схема приведена к 3НФ, что обеспечивает:
– отсутствие избыточности (нет дублирования категорий, товаров, пользователей); 
– целостность данных (все связи через внешние ключи, справочники вынесены отдельно); 
– удобство расширения и поддержки (можно добавлять новые категории, товары, метрики без изменения структуры других таблиц).


## **Функциональные возможности**

### Диаграмма вариантов использования

Диаграмма вариантов использования отражает взаимодействие двух ос-новных ролей пользователей с системой: менеджер по продажам и директор. Оба они являются специализированными актёрами, которые наследуют об-щий функционал пользователя. Общим для всех пользователей является воз-можность работать с отчётами и просматривать результаты анализа.
Менеджер по продажам обладает расширенными функциями управле-ния данными. Он может: 
– загружать Excel файл с данными продаж; 
– выполнять анализ данных; 
– строить таблицы и дашборды (анализ всегда включает визуализацию); 
– редактировать Excel файл в случае ошибок или необходимости об-новления; 
– формировать итоговый отчёт в удобном формате.
Директор выполняет функции принятия решений на основе готовых ре-зультатов. Он может: 
– просматривать дашборды, чтобы оперативно оценивать показатели; 
– скачивать отчёт в формате Excel или PDF для дальнейшего использо-вания.
Диаграмма вариантов использования представлена на рисунке 1.

<img width="826" height="543" alt="image" src="https://github.com/user-attachments/assets/6e912cf0-ecb1-418e-a732-b130ab67e0df" />

Рисунок 1 – Диаграмма вариантов использования

### User-flow диаграммы

ОДля наглядного представления логики работы менеджера по продажам в аналитическом приложении была построена пользовательская диаграмма. Она отражает последовательность действий от момента авторизации до анализа ключевых показателей и выгрузки отчёта. На схеме показаны основные шаги, развилки и возможные варианты завершения процесса, что позволяет визуализировать сценарий использования системы и продемонстрировать его целостность.

 <img width="3840" height="364" alt="Untitled diagram _ Mermaid Chart-2025-10-06-192759" src="https://github.com/user-attachments/assets/ae540b1a-aed0-430e-a5e4-5d96419efb19" />


Рисунок 1 – User flow диаграмма менеджера по продажам

Менеджер входит в аналитическое приложение, используя свои учётные данные. В личном кабинете менеджер получает доступ к основным функциям: загрузке данных, проверке корректности, анализу KPI и формированию отчётов.
Первым шагом менеджер переходит в раздел «Загрузка данных» и выбирает Excel файл с актуальной информацией о продажах и остатках. Система проверяет корректность структуры и содержания файла. Если обнаружены ошибки, менеджеру отображается сообщение с указанием проблем, и он может исправить файл и повторно загрузить его. Если данные корректны, система подтверждает успешную загрузку.
После загрузки менеджер переходит в раздел «Аналитика». Здесь он может просматривать ключевые показатели эффективности: продажи, остатки, прибыль, эффективность акций и средний чек. Для уточнения анализа менеджер применяет фильтры: по периоду и по категории товаров. Фильтры могут использоваться как по отдельности, так и совместно.
На основе выбранных параметров система формирует дашборд с актуальными данными. Менеджер анализирует показатели, выявляет отклонения и формирует выводы. При необходимости он может вернуться к загрузке данных и обновить информацию.
Завершающим этапом является выгрузка отчёта. Менеджер выбирает формат (Excel или PDF), после чего система формирует файл и предоставляет его для скачивания. Отчёт может быть передан директору или использован для внутреннего анализа.
Завершив работу, менеджер выходит из приложения.
Для описания логики работы директора в аналитическом приложении также была построена пользовательская диаграмма. Она отражает ключевые шаги взаимодействия: от авторизации и просмотра агрегированных показателей до применения фильтров и анализа дашбордов. Диаграмма демонстрирует, что директор может как просматривать общие данные без фильтрации, так и уточнять показатели по периоду и категории, получая более детализированную картину. Завершающим этапом сценария является выгрузка отчёта, который может быть использован для управленческих решений.

<img width="3840" height="394" alt="Untitled diagram _ Mermaid Chart-2025-10-06-192528" src="https://github.com/user-attachments/assets/97494f8c-75ca-4cfd-a636-19ede188c420" />


 
Рисунок 2 – User flow диаграмма директора

Директор начинает работу с аналитическим приложением с авторизации в системе. На главной странице директор получает доступ к агрегированным показателям: ключевым метрикам продаж, прибыли, динамике и эффективности акций. Далее возможны два сценария: просмотр дашбордов без фильтрации и с применением фильтров – директор уточняет данные, выбирая период и категорию товаров. Фильтры могут использоваться как по отдельности, так и совместно.
После применения фильтров система формирует обновлённый дашборд, отражающий показатели в заданных разрезах. Директор просматривает данные, анализирует динамику и выявляет тенденции.
Завершающим этапом является выгрузка отчёта. Директор выбирает формат (Excel или PDF), система формирует файл и предоставляет его для скачивания. Отчёт может быть использован для подготовки управленческих решений или передачи в другие подразделения.
Завершив работу, директор выходит из приложения.


## **Детали реализации**

### UML-диаграммы

Диаграмма компонентов отражает модульную структуру программного средства. Система разделена на три основных слоя: клиентский интерфейс (Frontend), серверное приложение (Backend) и база данных (Database).
<img width="975" height="779" alt="image" src="https://github.com/user-attachments/assets/d4bcee31-afad-41f6-abcf-f9aa23e87154" />

 
Рисунок 2 – Диаграмма компонентов

Диаграмма показывает архитектуру системы как поток данных: источ-ники (API, базы, файлы) передают информацию в сервисный слой, где выпол-няются трансформация, фильтрация, агрегация, визуализация и построение отчётов. Безопасность обеспечивается через JWT, OAuth и контроль прав пользователей. Далее слой «Connect» связывает сервисы с пользовательскими сценариями, а на выходе данные отображаются в UX паттернах – дашбордах, отчётах и визуализациях. Таким образом, схема отражает полный цикл: от получения данных до их наглядного представления пользователю.

Диаграмма размещения отражает физическую архитектуру программно-го средства. Система развёрнута в трёхуровневой конфигурации: клиентский уровень, сервер приложений и уровень базы данных.

 <img width="975" height="618" alt="image" src="https://github.com/user-attachments/assets/11534c88-b4f6-44df-a172-4640a2acb9e4" />

Рисунок 3 – Диаграмма размещения

Диаграмма отражает трёхуровневую архитектуру системы и распреде-ление её компонентов по узлам.
На стороне клиента работает браузер, в котором запускается React приложение, собранное с помощью Vite и написанное на TypeScript. В браузере загружается index.html, а также TS бандлы и React компоненты в формате .tsx. Пользователь взаимодействует с системой через HTTPS, отправ-ляя запросы и получая JSON ответы, содержащие отчёты и дашборды.
Frontend сервер отвечает за доставку статических файлов и компонен-тов приложения. Он обслуживает index.html, TypeScript бандлы и React компоненты, а также обеспечивает связь с бэкендом через REST API. Для безопасности используется HTTPS и передача JWT токенов, что гаранти-рует проверку подлинности и контроль доступа.
Backend сервер реализован на Java с использованием Spring Boot. Он запускается как JAR файл и содержит REST API контроллеры, сервисы биз-нес логики и фильтры безопасности. Здесь выполняются ключевые функции системы: загрузка и проверка файлов, анализ данных, генерация отчётов и формирование дашбордов. JWT аутентификация обеспечивает разграничение прав доступа для разных ролей пользователей (например, менеджер и дирек-тор).
Сервер базы данных MySQL хранит все сущности системы. В таблицах находятся пользователи, роли, загруженные файлы, данные продаж, результа-ты анализа и отчёты. Доступ к базе осуществляется через Spring Data JPA/Hibernate, что обеспечивает надёжное взаимодействие между приложени-ем и хранилищем.
Взаимодействие компонентов происходит следующим образом: браузер загружает фронтенд приложение с сервера, затем отправляет запросы на бэк-енд по HTTPS с JWT токенами. Бэкенд обрабатывает запросы, выполняет биз-нес логику и обращается к базе данных через JDBC/Hibernate. После этого ре-зультаты анализа и отчёты возвращаются в браузер в формате JSON и отоб-ражаются пользователю в виде дашбордов и визуализаций.
Таким образом, диаграмма демонстрирует современную архитектуру аналитической системы, где фронтенд на React + Vite с TypeScript обеспечива-ет удобный интерфейс, бэкенд на Spring Boot реализует бизнес логику и без-опасность, а MySQL служит надёжным хранилищем данных.

Диаграмма последовательности отражает динамику взаимодействия участников системы во времени.
 
 <img width="779" height="810" alt="image" src="https://github.com/user-attachments/assets/4181b1d6-228d-48dd-b87c-b0d6abbf04c9" />

Рисунок 4 – Диаграмма последовательности

Диаграмма последовательности отражает взаимодействие между мене-джером, системой аналитики и базой данных в процессе работы с Excel файлом. Сценарий начинается с того, что менеджер загружает файл в систему. Система проверяет его корректность: если файл некорректный, поль-зователю возвращается сообщение об ошибке, после чего менеджер редакти-рует файл и повторно загружает его. При успешной проверке система сохра-няет данные в базе и подтверждает выполнение операции. Таким образом за-вершается процесс загрузки.
Далее менеджер инициирует анализ данных. Система извлекает необхо-димые сведения из базы и выполняет расчёты: показатели продаж, выручку, средний чек и количество транзакций. После завершения анализа результаты сохраняются в базе данных, а менеджеру отправляется подтверждение о вы-полнении операции.
В целом диаграмма показывает полный цикл взаимодействия: от загруз-ки и проверки исходного файла до анализа и сохранения результатов. Она подчёркивает роль менеджера как инициатора процессов, роль системы ана-литики как обработчика данных и роль базы данных как хранилища информа-ции.

Диаграмма деятельности отражает последовательность действий и воз-можные ветвления в ключевых процессах системы.

 <img width="635" height="873" alt="image" src="https://github.com/user-attachments/assets/985fc943-a684-497b-8439-9035af19f6f6" />


Рисунок 5 – Диаграмма деятельности

Диаграмма бизнес процесса отражает взаимодействие трёх основных участников: менеджера, системы аналитики и директора. Менеджер отвечает за подготовку и загрузку исходных данных. Он загружает Excel файл в систе-му, при необходимости редактирует его и повторно загружает, если система сообщает об ошибке. Таким образом, менеджер обеспечивает корректность информации, которая будет использоваться для анализа.
Система аналитики выполняет ключевые операции обработки данных. После загрузки она проверяет файл на корректность: если обнаружены ошиб-ки, возвращается сообщение менеджеру; если файл корректный, данные со-храняются в базе. Далее система запускает анализ, извлекает данные из базы и рассчитывает основные показатели – выручку, средний чек и количество транзакций. Результаты анализа сохраняются в базе данных, после чего си-стема формирует итоговый отчёт.
Директор использует результаты работы системы для принятия управ-ленческих решений. Он просматривает дашборды, чтобы оперативно оценить показатели, и скачивает отчёт в формате Excel или PDF для дальнейшего ана-лиза и использования.

Диаграмма состояний демонстрирует жизненный цикл загружаемого  Excel-файла.
 
 <img width="635" height="822" alt="image" src="https://github.com/user-attachments/assets/cff437b1-89c0-4fe0-b533-b8c023bace6e" />

Рисунок 6 – Диаграмма состояний

Процесс начинается с состояния «Новый», когда файл только создан и ещё не загружен в систему. Далее он переходит в состояние «Загружен», что означает успешную загрузку пользователем. После этого система выполняет проверку формата файла. Если проверка проходит успешно, файл считается корректным и переводится в состояние «Проанализирован». На этом этапе данные обрабатываются, рассчитываются показатели и формируются резуль-таты анализа. После завершения анализа файл может быть архивирован, пере-ходя в состояние «Архивирован», что означает завершение его жизненного цикла.
Если же при проверке формата обнаружены ошибки, файл переводится в состояние «Некорректный». В этом случае пользователь должен исправить ошибки, после чего файл становится «Редактированным». Отредактирован-ный файл снова загружается в систему, возвращаясь в состояние «Загружен», и цикл проверки повторяется. Таким образом, диаграмма демонстрирует как прямой путь от загрузки до анализа и архивирования, так и альтернативный сценарий с выявлением ошибок, их исправлением и повторной загрузкой.
В целом диаграмма подчёркивает, что система поддерживает итератив-ную работу с Excel‑файлом: загрузка, проверка, возможное редактирование, повторная загрузка, анализ и архивирование. Она наглядно показывает, что процесс обработки данных не является линейным, а допускает возврат к предыдущим шагам для обеспечения корректности и качества информации.



### Спецификация API

Представить описание реализованных функциональных возможностей ПС с использованием Open API (можно представить либо полный файл спецификации, либо ссылку на него)

### Безопасность

Описать подходы, использованные для обеспечения безопасности, включая описание процессов аутентификации и авторизации с примерами кода из репозитория сервера

### Оценка качества кода

Используя показатели качества и метрики кода, оценить его качество

---

## **Тестирование**

### Unit-тесты

Представить код тестов для пяти методов и его пояснение

### Интеграционные тесты

Представить код тестов и его пояснение

---

## **Установка и  запуск**

### Манифесты для сборки docker образов

Представить весь код манифестов или ссылки на файлы с ними (при необходимости снабдить комментариями)

### Манифесты для развертывания k8s кластера

Представить весь код манифестов или ссылки на файлы с ними (при необходимости снабдить комментариями)

---

## **Лицензия**

Этот проект лицензирован по лицензии MIT - подробности представлены в файле [[License.md|LICENSE.md]]

---

## **Контакты**

Автор: email
